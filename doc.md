Um CRUD (Create, Read, Update & e Delete) é uma das melhores formas de se testar o conhecimento com uma stack específica, muitas vezes é cobrado em entrevistas de emprego e é bastante valorizado por iniciantes, é um marco importante para qualquer Dev seu primeiro CRUD.

Vamos começar criando o projeto com django-admin startproject crud, o Django sozinho é encarregado de  criar o arquivo e configurações iniciais. Uma vez com o projeto criado vamos as configurações básicas de sempre: Trocar  idioma, trocar fuso horário, definir a pasta para templates e o mais importante, criar o app principal, que neste CRUD chamarei de core, e adiciona-lo aos installed apps.

Uma vez com o app criado vamos criar o arquivo urls.py onde vamos adicionar os urls do site em si. Uma vez com o arquivo criado vamos só linka-lo com o urls.py do projeto principal por enquanto, mais tarde faremos as rotas com o views.py nele.

Outra coisa importante logo de início é criar a pasta de templates onde ficará o HTML do site. Pasta  criada, vamos criar também o HTML. Nomearei de create_user pois a primeira função que faremos será a Create. Façamos o esqueleto básico do HTML com um simples Hello World e para esse caso específico utilizarei os arquivos de CSS da Bootstrap para não ficar algo tão mal apresentável.

Estrutura básica criada e configurada vamos começar a colocar a mão na massa. A primeira coisa que precisamos é de uma rota que chame uma função para exibir o HTML. No views.py faremos uma função create_user (Vai entender o motivo deste nome mais a frente) que receberá como parâmetro o request e terá como resposta um return render com parâmetros request e nosso HTML (create_user.html). Função pronta vamos configurar a rota no urls.py, lembrando sempre de importar as views e o path, faremos uma lista urlpatterns com path em create_user, receberá o views.create_user e terá o nome de create_user também. Pronto, a página inicial já pode ser exibida acessando localhost:8000/create_user.

Vamos começar a ir um pouco mais a fundo e fazer nosso Create, pra  isso precisaremos começar a trabalhar com banco de dados, algo que o Django torna super simples. No models.py criaremos uma classe chamada usuario, seus parâmetros são models.Model, o primeiro é o módulo dos models em si e o segundo é a classe Model. Nele vão dois campos, nome e email (sim, faremos um CRUD super simples), o primeiro é um charfield que colocaremos max_length=100 e o segundo um emailfield que colocaremos Unique=True (Para um exemplo de CRUD simples como esse Unique=True não é realmente necessário e é importante lembrar que se ativado gerará erro ao tentar cadastrar um email já existente no banco de dados). Models prontos vamos executar makemigrations e migrate para criar nossa tabela no banco de dados, isso criará o db.sqlite3.

Agora vamos voltar ao HTML pois é nele que estarão os campos que preencherão esta tabela. De início precisamos de um lugar para inserir os dados e para que o Django receba estes dados precisamos de 2 coisas: Um form e um método. Sobre o form é só criar um <form> básico com 3 inputs, text, email e submit, esta parte é importante pois os nomes que daremos a cada um desses imputs serão os mesmos a serem mencionados no views.py quando formos configurar o POST. Falando em POST vamos ao segundo item, o método...

Sempre que você faz uma requisição em um site há um método por trás daquela requisição, para exibir páginas por exemplo usamos o método GET, porém quando enviar um fórmulário esse método muda para POST e é exatamente essa mudança de métodos que será nosso trigger para a função de captura de dados.

Defina method="POST" (sempre maiúsculo) no forms e pronto, temos um fórmulário que recebe nome e email e o botão os envia via POST, vamos programar a lógica de captura agora. No views.py manteremos o return render para a página HTML, porém vamos coloca-lo dentro de um if request.method == 'GET', isso fará com que sempre que o método for GET ele carregue a página HTML e é exatamente isso que acontece quando acessamos o url da página. Continuaremos com um elif request.method == 'POST' e tudo que fizermos daqui pra baixo só acontecerá caso o método da página seja POST, faremos assim... Criaremos duas variáveis para nome e email que será = a request.POST.get('nome do input no HTML'), lembra  que disse que  o nome dos inputs no HTML seria importante? É aqui que eles entram. Então ficamos com algo parecido com:

name = request.POST.get('nome')
email = request.POST.get('email')

Essa expressão traduzida faz o seguinte: Faça uma requisição POST e pegue tal valor, uma vez com esse valor salvo atribua ele a esta variável. Com nossas  variáveis com o valor colocado no formulário vamos fazer com que ele seja traduzido para o banco de dados. Para fazer isso precisamos importar o nome da tabela que fizemos no model, de .models importe usuario. Agora criamos um objeto e atribuímos a ele o valor da nossa tabela do banco de dados que importamos do models, chamarei de user e ficará user = usuario, dentro desse objeto vamos traduzir as outras duas variáveis que pegamos mais cedo no forms para os valores que o banco de dados espera, então nas chaves do objeto user = usuario teremos name=name e email=email. Agora tudo que precisamos fazer é salvar essas alterações, pra isso utilizamos o user.save que salvará as alterações desse nosso objeto que tem como valor as colunas do banco de dados. 

Lógica pronta, basta redirecionarmos o usuário a mesma página com return, redirect (não se esqueça  de importar o redirect) 'create_user'. Outra coisa que não podemos esquecer é de definir a ação do nosso formulário no HTML, este precisa ter como ação a mesma url que ele usa para capturar as informações, ou seja, ele mesmo. Como o Django trabalha com urls dinâmicas vamos usar  uma tag chamada url no action que resultará em algo como: {% url 'create_user' %}.

Quase me esqueci de mencionar sobre o cstf_token que é estritamente necessário para enviarmos qualquer coisa via POST... O csrf (Cross-Site Request Forgery) é um token de segurança que o Django usa para evitar fraude de formulário e impede qualquer formulário de ser enviado se não tiver ele. Vamos adicioná-lo usando {% csrf_token %} logo após a nossa tag do form, só isso já é o suficiente para ativa-lo e nos permitir enviar o formulário sem mais problemas.

Sistema de captura pronto, basta colocar dados nos campos, dar submit no botão e vir no db.sqlite3 na pasta do projeto para ver os dados salvos, já que ainda não fizemos o Read do nosso CRUD.

====================================

Terminamos o Create, vamos ao Read, este é mais simples já que temos toda a estrutura do projeto pronta.
O Read consiste em mostrar as informações salvas no banco de dados em uma página. O que vamos fazer será utilizar do terceiro parâmetro do nosso return render da função create_user. O primeiro é o request para o site saber o que faz, o segundo é o arquivo que deve ser exibido e o terceiro é o que chamamos de "contexto", este parâmetro associa uma variável a um objeto e é exatamente essa associação que vamos usar.

Voltemos para o nosso views.py e lembra que definios um if else para POST e GET? Queremos exibir a lista sempre que o usuário acessar o site e para isso vamos usar o GET já que ele faz exatamente isso, exibe algo quando o usário acessa o site. 
Na parte do GET faremos assim: Criaremos uma variável chamada de usuariosdb e a ela atribuíremos o valor de usuario.objects.all(), este comando gera uma QuerySet (uma lista com todos os dados do banco que é filtrável) e salva nessa variável usuariosdb. Uma vez feito isso vamos passar nosso terceiro parâmetro para o return render, o contexto, ele é colocado assim: {'usuarios': usuariosdb}. 
O que está a esquerda é a chave que o HTML usa para acessar o que está a direita, isso é chamado de context ou contexto. É uma  compilação de 3 passos: usuario.objects.all() se refere a consulta ao banco de dados, usuariosdb é uma variável nova que armazena os dados da consulta e 'usuarios' é a chave que o HTML usa para acessar o valor em usuariosdb. Essa parte é meio confusa, releia e tente fazer sozinho para tentar entender melhor.

Agora vamos para o nosso HTML, como queremos listar e vamos mexer com listas nada melhor do que uma tabela. Utilizarei novamente modelos do Bootstrap para esse projeto e criarei inicialmente só dois headers, o nome e o email. Agora vem a parte interessante... Vamos criar um for dentro do nosso HTML, isso mesmo, um laço de repetição num HTML. Se você é novato no Django isso pode parecer um pouco estranho, mas como o Django trabalha com renderização dinâmica de página é possível usar lógica de programação dentro do próprio HTML, nesse caso vamos usar um for. Para isso acionaremos as tags  de comando do Django e nela faremos o for: {% for i in usuarios %}. Isso lista o parâmetro i para cada elemento dentro de usuarios e podemos saber quem é cada i graças ao contexto que usamos no views.py anteriormente, agora é só alterar os valores da lista. Não se esqueça também de fechar o for no fim da tabela já que não podemos usar identação para lógica, usamos {% endfor %}.

Algo que quase me esqueço de mencionar: É importante que essa lista seja feita com elementos do tipo input para já facilitar quando formos fazer o Update (ultima parte), sim, faremos um Read e um Update juntos, isso compromete a UX, mas o intuito deste CRUD é ser o mais simples, rápido e funcional possível, então isso basta. Então em cada header teremos um input dos respectivos text e email, os nomes também precisam ser condizentes e o mais importante é o valor de cada input que usaremos as tags dinâmicas mais uma vez para o for. {{i.name}} no input de nome e {{i.email}} no input de email. Agora basta iniciar o servidor e caso já haja dados no banco de dados eles devem ser exibidos ali, caso não, basta criar e eles aparecerão automáticamente na página, já que o redirecionamento do botão de enviar dados leva para a mesma página que mostramos as informações.

====================================

Chegamos na metade do nosso CRUD, já fizemos o Create e o Read, agora vamos para o Delete, já que, para mim, o Update é a parte mais complicada e decidi deixá-la para o final.

Para fazermos o Delete (e o Update também mais pra frente) vamos ter que trabalhar com IDs do Django e com urls personalizadas... Faremos uma url que pega o ID real do objeto no banco, chama uma função que procura no banco o ID com o mesmo valor e o deleta, após deletar basta enviar o usuário de volta para a página principal.

Vamos começar pelo views.py, faremos uma nova função que chamaremos de delete_user e terá como parâmetros request e id (jajá explicarei este id) e dentro dela criaremos uma variável usuariodel = get_object_or_404(usuario, id=id). Ainda não está pronto, mas para fazer sentido precisamos ir para o urls.py e criar a url que acessará essa função, a ela daremos o caminho de delete_user/<int:id>, chamaremos a função com views.delete_user e nomearemos de delete_user. Agora sim podemos ir pras explicações...

Iremos acessar essa url somente quando acionarmos o botão de deletar usuário (que será uma âncora, não um botão) e essa url aciona a nossa tag de for i.id (sim, vamos usar for novamente), essa tag captura o id e o trás para a url. Sobre a função no views.py, ela recebe o valor de id que colocamos na url (já que tem um parâmetro pra isso) e pega um objeto dentro da classe do banco de dados usuario correspondente ao id da url. O id passado pela url é o mesmo id do banco, já que a própria função o captura, o que fazemos em todo o resto é basicamente manusear esse valor para que ele chegue na parte de deletar o usuário com base no id. Confuso, não? Quando finalizarmos toda a função eu faço uma explicação mais completa sobre.

Agora que o fluxo de captura está completo podemos decidir o que fazer com o objeto do id que foi capturado. Faremos na mesma função um usuariodel.delete() e um return redirect('create_user'). Isso faz com que o objeto capturado seja deletado e após isso o usuário seja redirecionado para a mesma página que estava (já que é a única que estamos trabalhando). Agora sim, tudo pronto na parte de urls e views, vamos para o HTML.

Vamos fazer nosso botão como uma coluna da nossa tabela. Nomeei o header como Delete e adicionei uma linha com uma âncora chamada Delete, Bootstrap marca presença novamente na estilização, estamos fazendo um redirecionamento então não usaremos botão. Nessa âncora utilizarei novamente as tags do Django, dessa vez a url: {% url 'delete_user' i.id %}, percebe a presença do i? É por que precisamos incluílo dentro do for que fizemos anteriormente para o Read, ele é crucial pois é através dele que iremos capturar o exato id do objeto selecionado, este i.id já é o ID real do objeto dentro do banco. E pronto, isso conclui nosso fluxo de delete, agora vamos novamente as explicações, fazer é bem mais fácil do que entender

A âncora só irá aparecer caso haja pelo menos 1 usuário no banco, ao clicar ela o redireciona para a nossa url dinâmica, antes delete_user/<int:id>, com as tags dinâmicas se torna delete_user/1 (ou o número correspondente ao id do objeto no banco). Isso faz nossa função do view capturar esse valor na nossa variável de usuariodel e então a deleta, após isso o redirect mando o usuário de volta a página principal.

====================================

Chegamos ao final do nosso CRUD e vamos fazer a última parte, o Update, essa parte é bem similar ao Delete, a grande diferença é o que vamos fazer com os dados após termos acesso a eles. Lembram-se que no inicio dessa documentação, lá no Read, eu disse para fazer os campos de exibição do tipo input="text"? Faremos um Update integrado ao Read a partir disso.

Com eu disse antes, o Update será bem similar o Delete, então já podemos começar  criando uma função no views.py com request e id (trabalharemos com id novamente) e uma variável usuarioup = get_object_or_404(usuario, id=id). Praticamente idêntico ao delete, não é mesmo? Faremos o mesmo com o urls.py: Uma url usuario_update/<int:id>, views.update_user chamada update_user. Memsma lógica do delete, o id trazido da url pelo for é recebido nessa nossa variável, agora vamos ver o que fazemos com ele.

Antes, no Delete, apenas deletavámos o objeto que o get pegava através do id, agora vamos atribuir novos valores a eles, de uma forma similar ao que fizemos no Create. 

name = request.POST.get('nome')
email = request.POST.get('email')

Bastante similar ao Create em... Isso pega os campos nome e email do nosso input de texto (que atualmente só exibe os dados) e guarda no nome das colunas do banco de dados. Uma vez com o id da linha que queremos atualizar e os dados novos basta convergir. 

usuarioup.name = name
usuarioup.email = email

E então basta salvar com usuarioup.save que teremos nossos dados atualizados. Mais uma vez, return redirect manda o usuário de volta para a mesma página, já com os dados atualizados. Agora vamos configurar isso no HTML, que também é bem parecido com o que foi o Delete.

Note a presença do POST na request, enviaremos formulário, crie uma nova linha na tabela do HTML, nomeei o Reader de Update e criei um input do tipo submit dentro de um formulário, lembre-se de incluir os campos também, eles são cruciais já que estamo fazendo um Read e um Update unidos, os mesmos campos que usamos para ver os dados do banco vamos usar para atualizá-lo via formulário. A esse input chamei de Update também e coloquei estilo com Bootstrap, algo importante também é deixar tudo dentro do for.

A configuração inportante aqui é no <form> e não no botão em si, faremos exatamente a mesma coisa que fizemos no Delete para pegar o id através do for: {% url 'update_user' i.id %}. Terminamos? Não, quase me esqueço do csrf token novamente, coloque-o logo abaixo do form, em tags: {% csrf_token %}. Agora sim, basta irmos ao site testar.

Um adendo importante que nesse projeto em específico pode não ter ficado claro: O Update geralmente precisa do mesmo esquema de GET e POST para receber e exibir informações, mas no nosso caso de Read e Update unificados isso não é necessário porque a própria página já entrega os dados preenchidos, então não existe uma tela separada para carregar via GET. Caso tente reproduzir usando páginas separadas é importante separar POST de GET.