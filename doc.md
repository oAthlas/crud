Um CRUD (Create, Read, Update & e Delete) é uma das melhores formas de se testar o conhecimento com uma stack específica, muitas vezes é cobrado em entrevistas de emprego e é bastante valorizado por iniciantes, é um marco importante para qualquer Dev seu primeiro CRUD.

Vamos começar criando o projeto com django-admin startproject crud, o Django sozinho é encarregado de  criar o arquivo e configurações iniciais. Uma vez com o projeto criado vamos as configurações básicas de sempre: Trocar  idioma, trocar fuso horário, definir a pasta para templates e o mais importante, criar o app principal, que neste CRUD chamarei de core, e adiciona-lo aos installed apps.

Uma vez com o app criado vamos criar o arquivo urls.py onde vamos adicionar os urls do site em si. Uma vez com o arquivo criado vamos só linka-lo com o urls.py do projeto principal por enquanto, mais tarde faremos as rotas com o views.py nele.

Outra coisa importante logo de início é criar a pasta de templates onde ficará o HTML do site. Pasta  criada, vamos criar também o HTML. Nomearei de create_user pois a primeira função que faremos será a Create. Façamos o esqueleto básico do HTML com um simples Hello World e para esse caso específico utilizarei os arquivos de CSS da Bootstrap para não ficar algo tão mal apresentável.

Estrutura básica criada e configurada vamos começar a colocar a mão na massa. A primeira coisa que precisamos é de uma rota que chame uma função para exibir o HTML. No views.py faremos uma função create_user (Vai entender o motivo deste nome mais a frente) que receberá como parâmetro o request e terá como resposta um return render com parâmetros request e nosso HTML (create_user.html). Função pronta vamos configurar a rota no urls.py, lembrando sempre de importar as views e o path, faremos uma lista urlpatterns com path em create_user, receberá o views.create_user e terá o nome de create_user também. Pronto, a página inicial já pode ser exibida acessando localhost:8000/create_user.

Vamos começar a ir um pouco mais a fundo e fazer nosso Create, pra  isso precisaremos começar a trabalhar com banco de dados, algo que o Django torna super simples. No models.py criaremos uma classe chamada usuario, seus parâmetros são models.Model, o primeiro é o módulo dos models em si e o segundo é a classe Model. Nele vão dois campos, nome e email (sim, faremos um CRUD super simples), o primeiro é um charfield que colocaremos max_length=100 e o segundo um emailfield que colocaremos Unique=True (Para um exemplo de CRUD simples como esse Unique=True não é realmente necessário e é importante lembrar que se ativado gerará erro ao tentar cadastrar um email já existente no banco de dados). Models prontos vamos executar makemigrations e migrate para criar nossa tabela no banco de dados, isso criará o db.sqlite3.

Agora vamos voltar ao HTML pois é nele que estarão os campos que preencherão esta tabela. De início precisamos de um lugar para inserir os dados e para que o Django receba estes dados precisamos de 2 coisas: Um form e um método. Sobre o form é só criar um <form> básico com 3 inputs, text, email e submit, esta parte é importante pois os nomes que daremos a cada um desses imputs serão os mesmos a serem mencionados no views.py quando formos configurar o POST. Falando em POST vamos ao segundo item, o método...

Sempre que você faz uma requisição em um site há um método por trás daquela requisição, para exibir páginas por exemplo usamos o método GET, porém quando enviar um fórmulário esse método muda para POST e é exatamente essa mudança de métodos que será nosso trigger para a função de captura de dados.

Defina method="POST" (sempre maiúsculo) no forms e pronto, temos um fórmulário que recebe nome e email e o botão os envia via POST, vamos programar a lógica de captura agora. No views.py manteremos o return render para a página HTML, porém vamos coloca-lo dentro de um if request.method == 'GET', isso fará com que sempre que o método for GET ele carregue a página HTML e é exatamente isso que acontece quando acessamos o url da página. Continuaremos com um elif request.method == 'POST' e tudo que fizermos daqui pra baixo só acontecerá caso o método da página seja POST, faremos assim... Criaremos duas variáveis para nome e email que será = a request.POST.get('nome do input no HTML'), lembra  que disse que  o nome dos inputs no HTML seria importante? É aqui que eles entram. Então ficamos com algo parecido com:

name = request.POST.get('nome')
email = request.POST.get('email')

Essa expressão traduzida faz o seguinte: Faça uma requisição POST e pegue tal valor, uma vez com esse valor salvo atribua ele a esta variável. Com nossas  variáveis com o valor colocado no formulário vamos fazer com que ele seja traduzido para o banco de dados. Para fazer isso precisamos importar o nome da tabela que fizemos no model, de .models importe usuario. Agora criamos um objeto e atribuímos a ele o valor da nossa tabela do banco de dados que importamos do models, chamarei de user e ficará user = usuario, dentro desse objeto vamos traduzir as outras duas variáveis que pegamos mais cedo no forms para os valores que o banco de dados espera, então nas chaves do objeto user = usuario teremos name=name e email=email. Agora tudo que precisamos fazer é salvar essas alterações, pra isso utilizamos o user.save que salvará as alterações desse nosso objeto que tem como valor as colunas do banco de dados. 

Lógica pronta, basta redirecionarmos o usuário a mesma página com return, redirect (não se esqueça  de importar o redirect) 'create_user'. Outra coisa que não podemos esquecer é de definir a ação do nosso formulário no HTML, este precisa ter como ação a mesma url que ele usa para capturar as informações, ou seja, ele mesmo. Como o Django trabalha com urls dinâmicas vamos usar  uma tag chamada url no action que resultará em algo como: {% url 'create_user' %}.

Quase me esqueci de mencionar sobre o cstf_token que é estritamente necessário para enviarmos qualquer coisa via POST... O csrf (Cross-Site Request Forgery) é um token de segurança que o Django usa para evitar fraude de formulário e impede qualquer formulário de ser enviado se não tiver ele. Vamos adicioná-lo usando {% csrf_token %} logo após a nossa tag do form, só isso já é o suficiente para ativa-lo e nos permitir enviar o formulário sem mais problemas.

Sistema de captura pronto, basta colocar dados nos campos, dar submit no botão e vir no db.sqlite3 na pasta do projeto para ver os dados salvos, já que ainda não fizemos o Read do nosso CRUD.